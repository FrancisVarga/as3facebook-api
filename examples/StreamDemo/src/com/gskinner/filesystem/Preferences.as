/*** Preferences by gskinner.com. Nov 4, 2008* Visit www.gskinner.com/blog for documentation, updates and more free code.*** Copyright (c) 2008 Grant Skinner* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.**/package com.gskinner.filesystem {		import flash.data.EncryptedLocalStore;	import flash.events.EventDispatcher;	import flash.filesystem.File;	import flash.filesystem.FileMode;	import flash.filesystem.FileStream;	import flash.net.registerClassAlias;	import flash.utils.ByteArray;		public class Preferences extends EventDispatcher {				protected var fileRef:File;		protected var fileStream:FileStream;				protected var keyHash:Object; //Keys for all the prefs (both secured and unsecured)		protected var localEncryptedPrefs:Object; //Prefs loaded / saved into an secure file		protected var localUnsecuredPrefs:Object; //Prefs loaded / saved into an unsecure file				//Store off these ByteArrays as Class vars, to attempt tp keep memory clean.		protected var unsecuredPrefs:ByteArray;		protected var securedPrefs:ByteArray;				protected static var _instance:Preferences;				protected var _dirty:Boolean = true;				protected const VERSION:String = '0.1.0'; //wdg: version number, saved to the users system, so if in the future we make changes, we can port old prefs correctly.		protected const VERSION_VALUE_NAME:String = 'com.gskinner.filesystem.Prefrences::version';			protected const KEY_VALUE_NAME:String = 'com.gskinner.filesystem.Prefrences::keys';		protected const SECURE_VALUE_NAME:String = 'com.gskinner.filesystem.Prefrences::secured';				public function Preferences() {			if (_instance != null) { throw new Error('Preferences class may not be instaniated.'); }						registerClassAlias('PreferenceKey', PreferenceKey);						fileRef = new File();			fileRef.url = File.applicationStorageDirectory.url + 'prefs.dat';						fileStream = new FileStream();			load();		}				public static function setPref(p_name:String, p_value:*, p_encrypt:Boolean = false, p_forceSave:Boolean = false):void { getInstance().setPref(p_name, p_value, p_encrypt, p_forceSave); }		public function setPref(p_name:String, p_value:*, p_encrypt:Boolean, p_forceSave:Boolean=false):void {			var key:PreferenceKey = getKey(p_name);						//Clear the old value, if its encrypted state is different from any previous one. 			if (key != null && key.encrypted !== p_encrypt) {				removePref(p_name);			}						keyHash[p_name] = new PreferenceKey(p_name, p_encrypt);						if (p_encrypt == true) {				localEncryptedPrefs[p_name] = p_value;			} else {				localUnsecuredPrefs[p_name] = p_value;			}						 _dirty = true;			if (p_forceSave) { save(); }		}				public static function getPref(p_name:String):* { return getInstance().getPref(p_name); }		public function getPref(p_name:String):* {			var key:PreferenceKey = getKey(p_name);			if (key == null) { return null; }			if (key.encrypted === true) {				return localEncryptedPrefs[p_name];			} else {				return localUnsecuredPrefs[p_name];			}		}				public static function removePref(p_name:String):void { return getInstance().removePref(p_name); }		public function removePref(p_name:String):void {			var key:PreferenceKey = getKey(p_name);			if (key == null) { return; }						if (key.encrypted === true) {				localEncryptedPrefs[p_name] = null;				delete localEncryptedPrefs[p_name];			} else {				localUnsecuredPrefs[p_name] = null;				delete localUnsecuredPrefs[p_name];			}						keyHash[p_name] = null;			delete keyHash[p_name];						_dirty = true;		}				public static function save():void { getInstance().save(); }		public function save():void {			if (_dirty == false) { return; } //Nothing has been changed since the last save, so don't re-save.						//Save the unsecure prefs and the keys			localUnsecuredPrefs[KEY_VALUE_NAME] = keyHash;			localUnsecuredPrefs[VERSION_VALUE_NAME] = VERSION;						unsecuredPrefs = new ByteArray();			unsecuredPrefs.writeObject(localUnsecuredPrefs);			unsecuredPrefs.compress();			fileStream.open(fileRef, FileMode.WRITE);			fileStream.writeBytes(unsecuredPrefs);			fileStream.close();						//Save the secured Prefs			securedPrefs = new ByteArray();			securedPrefs.writeObject(localEncryptedPrefs);			securedPrefs.compress();						EncryptedLocalStore.setItem(SECURE_VALUE_NAME, securedPrefs);						_dirty = false;		}				public static function get dirty():Boolean { return getInstance().dirty; }		public function get dirty():Boolean { return _dirty; }				private function getKey(p_key:String):PreferenceKey {			var tmpKey:PreferenceKey = keyHash[p_key];			return tmpKey;		}						private function load():void {			if (fileRef.exists) {				fileStream.open(fileRef, FileMode.READ);								unsecuredPrefs = new ByteArray();				//Need to try/catch here. Only way to find out if the readBytes fails.				//Read in unsecured prefs / keys				try {					fileStream.readBytes(unsecuredPrefs);					fileStream.close();										unsecuredPrefs.uncompress();					localUnsecuredPrefs = unsecuredPrefs.readObject();					keyHash = localUnsecuredPrefs[KEY_VALUE_NAME];				} catch(p_e:*) { throw p_e; }			}						//Read in secured prefs			securedPrefs = null;						try {				securedPrefs = loadELS();			/**			 * There was an error reading the Secure prefs, so .reset() and try again.			 * This will erase the prefs (if they still exsit), but chances are the user manually deleted the ELS from there system.			 * wdg:: I was receiving this error on OSX when I manually deleted the ELS from my Keychain.			*/			} catch (e:*) {				EncryptedLocalStore.reset();				securedPrefs = loadELS();			}						if (securedPrefs != null && securedPrefs.length > 0) {				securedPrefs.uncompress();				localEncryptedPrefs = securedPrefs.readObject();			}						if (localUnsecuredPrefs != null && localUnsecuredPrefs[VERSION_VALUE_NAME] != null && localUnsecuredPrefs[VERSION_VALUE_NAME] !== VERSION) {				//Port old prefs here (if needed)				switch (localUnsecuredPrefs[VERSION_VALUE_NAME]) {					case '0.1.1':				}			}						if (keyHash == null) { keyHash = {}; }			if (localUnsecuredPrefs == null) { localUnsecuredPrefs = {}; }			if (localEncryptedPrefs == null) { localEncryptedPrefs = {}; }		}				protected function loadELS():ByteArray {			return EncryptedLocalStore.getItem(SECURE_VALUE_NAME);		}				public static function toString():String { return getInstance().toString(); }		override public function toString():String {			var arr:Array = [];			for (var n:String in keyHash) {				arr.push(n + ': ' + keyHash[n]); 			}			return arr.join('\n');		}				protected static function getInstance():Preferences {			if (_instance == null) { _instance= new Preferences(); }			return _instance;		}			}}class PreferenceKey {	public var name:String;	public var encrypted:Boolean;		public function PreferenceKey(p_name:String = '', p_encrypted:Boolean = false) {		name = p_name;		encrypted = p_encrypted;	}		public function toString():String {		return 'name: ' + name + '  encrypted: ' + encrypted;	}}